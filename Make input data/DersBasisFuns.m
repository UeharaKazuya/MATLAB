% 参考文献　Trajectory Planning for Automatic Machines and Robots pp.467-479（内山先生に借りた）
% -------------- 入力値 ---------------
% u = ノットとノット間を刻んでいく時間的な奴 各離散時間で逐次代入
% i = uを含むノットスパンのインデックス ノットスパンインデックスは1から始まる
% p = 微分対象のスプラインの次数 元の関数が3次Splineなら p = 3ということ 
% n = Bspline基底関数の最大微分階数
% U[] =ノットベクトル 微分対象のスプラインで定義した[0 0 0 0 1 2 4 7 7 7 7]みたいにp+1個重ねているやつ

% --------------- 出力値 ----------------
% Ders[][] = 時間uで微分したときのB-Spline基底関数の値
% ---------------------------------------
% 現在の問題点
% （１）行列のインデックスズレる問題 for 分の初期値に+1をすると[i+j]でインデックスが意図しない値になってしまうのでだるい
%       → ゴリ押しの解決策　全体のインデックスを+1してC言語からMATLAB形式に合わせ、面倒な考えをすべて捨てる（これやったとこは「変更部」と書いてある）
% （２）変数iが一体何者なのか問題 →　解決！本の誤字だった：（誤：DersBasisFuns(u,j,p,n,U)）→正：DersBasisFuns(u,i,p,n,U)）
%       iはp469に示されたノットスパン [u(i) u(i+1))のこと　いつもの u∈[u(i) u(i+1))で扱ってるやつ
% ---------------------------------------
function Ders = DersBasisFuns(u,i,p,n,U)
    i = i-1; % 変更部：入力値のノットスパンインデックスを1から始めるためにごり押しした

    DR = zeros(1,p);
    DL = zeros(1,p);
    Du = zeros(p+1,p+1);
    a = zeros(p+1,p+1);
    Ders = zeros(p+1,p+1);
%-------------------- 基底関数の計算 -------------------------    
% DuはTrajectry Planning for Automatic Machines and Robots(B.11)の
% B^(p-k)_(j+i)で示されるB-Spline基底関数(p469のプログラムと同じ)

if u == 1 %一番最後の時間は計算出来ないので直接代入する 基底関数は最後１
    Ders(1,:) = [0,0,0,1];
else
    Du(1,1)=1.0;
    for j = 1:p % 初期値j=1,j <= pの意味 1から始まるのはDu[1][1]以降を計算するため MATLABならDu(2,2)
        DL(j+1) = u - U(i+1-j+1);% 変更部 %インデックス計算で－j があるからforの初期値をj=2ってするとインデックス計算で-2ってされるのがだるくて...
                                 % 全体のインデックスを全て1ずらしました...許してください未来のワシ..頭が回りませんでした
        DR(j+1) = U(i+j+1) - u;%変更部
        acc = 0.0;
        for r = 0:j-1%(r<jの意味)
            Du(j+1,r+1) = DR(r+1+1)+DL(j-r+1);%変更部
            temp = Du(r+1,j-1+1)/Du(j+1,r+1);%変更部
            
            Du(r+1,j+1) = acc + DR(r+1+1)*temp;%変更部
            acc = DL(j-r+1) * temp;%変更部
        end
        Du(j+1,j+1) = acc;%変更部
    end
    
    for j = 0:p % jはインデックスに用いられることもある　MATLABはインデックスが1から始まるので
                % 行列部分のインデックスだけ＋１を書き足して対策するのが楽
        Ders(0+1,j+1) = Du(j+1,p+1);%変更部
    end
    
end
% -------------- 式(B-11)の係数の計算 --------------
    for r = 0:p % r<=pの意味
        s1 = 0;
        s2 = 1;
        a(1,1) = 1.0;%変更部
        for k = 1:n %初期値k=1, k<=n
            d = 0.0;
            rk = r - k;
            pk = p - k;
            
            if r >= k
                a(s2+1,0+1) = a(s1+1,0+1) / Du(pk+1+1,rk+1);%変更部
                d = a(s2+1,0+1) * Du(rk+1,pk+1);%変更部
            end
            if rk >= -1
                j1 = 1;
            else
                j1 = -rk;
            end
            if r-1 <= pk
                j2 = k-1;
            else
                j2 = p-r;
            end
            for j = j1:j2 % 初期値j=j1, 条件j<=j2
                a(s2+1,j+1) = (a(s1+1,j+1) - a(s1+1,j-1+1)) / Du(pk+1+1,rk+j+1);%変更部
                d = d + a(s2+1,j+1) * Du(rk+j+1,pk+1);%変更部
            end
            if r <= pk
                a(s2+1,k+1) = -a(s1+1,k-1+1) / Du(pk+1+1,r+1);%変更部
                d = d + a(s2+1,k+1) * Du(r+1,pk+1);%変更部
            end
            Ders(k+1,r+1) = d;%変更部
            j = s1; s1 = s2; s2 = j;
        end
    end
    
    r = p;
    for k = 1:n %初期値k=1で k <= n
        for j=0:p
            Ders(k+1,j+1) = Ders(k+1,j+1) * r;%変更部
        end
        r = r*(p-k);
    end
       
end